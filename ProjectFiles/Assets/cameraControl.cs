using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using NUnit.Framework.Internal.Filters;
using System;
using UnityEditor;


public class cameraControl : MonoBehaviour {
	/* Control the movement and behaviour of the camera based on user input. Handles collisions, etc. */

	/* Constants. FRICTION value must be < ACCELERATION. These values determined by tests: what is most fun? 
	 * These are set to private such that they are always as written. */
	public static float MAX_SPEED = 50.0f;
	public static float ACCELERATION = 1.0f;
	public static float FRICTION = 0.35f;
	public static float FRICTION_THRESHOLD = 0.35f;
	public static float ROLL_SPEED = 3f;

	private float SENSITIVITY = 7f;

	/* Only X and Z can be controlled with keyboard. */
	private float xspeed;
	private float zspeed;

	/* Handle roll and mouse look. */
	private float yaw;
	private float pitch;
	private float roll;

	/* Terrain. */
	public Terrain terrain;

	void GetUserInput() {
		/* Add speed depending on arrow keys held. */

		/* Control roll. */

		if (Input.GetKey(KeyCode.E)) {
			roll = ROLL_SPEED;
		} else if (Input.GetKey(KeyCode.Q)) {
			roll = -ROLL_SPEED;
		} else {
			roll = 0f;
		}

		/* Control translation. */

		if (Input.GetKey(KeyCode.RightArrow) || Input.GetKey(KeyCode.D)) {
			if (xspeed < MAX_SPEED) {
				xspeed += ACCELERATION;
			}
		}

		if (Input.GetKey(KeyCode.UpArrow) || Input.GetKey(KeyCode.W)) {
			if (zspeed < MAX_SPEED) {
				zspeed += ACCELERATION;
			}
		}

		if (Input.GetKey(KeyCode.DownArrow) || Input.GetKey(KeyCode.S)) {
			if (zspeed > -MAX_SPEED) {
				zspeed -= ACCELERATION;
			}
		}

		if (Input.GetKey(KeyCode.LeftArrow) || Input.GetKey(KeyCode.A)) {
			if (xspeed > -MAX_SPEED) {
				xspeed -= ACCELERATION;
			}
		}
	}

	void ApplyDrag() {
		/* Slow down the camera's X and Z coordinate movements as necessary. */

		/* Position/translation. */

		if (xspeed < -FRICTION_THRESHOLD) {
			xspeed += FRICTION;
		}

		if (zspeed < -FRICTION_THRESHOLD) {
			zspeed += FRICTION;
		}

		if (xspeed > FRICTION_THRESHOLD) {
			xspeed -= FRICTION;
		}

		if (zspeed > FRICTION_THRESHOLD) {
			zspeed -= FRICTION;
		}
	}

	void ZeroSlowSpeeds() {
		/* Avoid a jittery camera by setting the speed to zero when necessary. */

		/* Position/translation. */

		if (xspeed <= FRICTION_THRESHOLD && xspeed >= -FRICTION_THRESHOLD) {
			xspeed = 0.0f;
		}

		if (zspeed <= FRICTION_THRESHOLD && zspeed >= -FRICTION_THRESHOLD) {
			zspeed = 0.0f;
		}
	}

	void PerformMovement() {
		/* After values are computed, actually move the camera. */

		/* Position/translation relative to mouse pointer. Movement plane generated by:
		 * - Vector from camera position to mouse.
		 * - Vector formed by roll angle.
		 */
		var movement = new Vector3(xspeed, 0.0f, zspeed);
		movement = Camera.main.transform.TransformDirection(movement);
		this.transform.localPosition += movement * Time.deltaTime;

		/* Roll, yaw, and pitch. */
		yaw = SENSITIVITY * Input.GetAxis("Mouse X");
		pitch = SENSITIVITY * Input.GetAxis("Mouse Y");

		transform.RotateAround(transform.position, this.transform.forward, -roll);
		transform.RotateAround(transform.position, this.transform.right, -pitch);
		transform.RotateAround(transform.position, this.transform.up, yaw);
	}

	void PreventOutOfBounds() {
		/* Stop the user from leaving the map. */
		var cx = this.transform.position.x;
		var cy = this.transform.position.y;
		var cz = this.transform.position.z;

		var len = terrain.terrainData.size[0]; /* This works because terrain is a square. */

		if (this.transform.position.x > len / 2) {
			this.transform.position = new Vector3(len / 2, cy, cz);
		} else if (this.transform.position.x < -len / 2) {
			this.transform.position = new Vector3(-len / 2, cy, cz);
		}

		if (this.transform.position.z > len / 2) {
			this.transform.position = new Vector3(cx, cy, len / 2);
		} else if (this.transform.position.z < -len / 2) {
			this.transform.position = new Vector3(cx, cy, -len / 2);
		}
	}

	void Start() {
		/* Initialise camera control script. */

		xspeed = 0.0f;
		zspeed = 0.0f;
		roll = 0.0f;
	}

	void Update() {
		/* Perform main logic based on strict order of method calls. */

		this.GetUserInput();
		this.PreventOutOfBounds();
		this.PerformMovement();
		this.ApplyDrag();
		this.ZeroSlowSpeeds();
	}

	void OnCollisionEnter(Collision collision) {
		/* Halt camera on collision. */
		xspeed = 0.0f;
		zspeed = 0.0f;
	}
}
